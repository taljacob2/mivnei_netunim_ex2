\hypertarget{class_min_heap}{}\doxysection{Min\+Heap$<$ K, V $>$ Class Template Reference}
\label{class_min_heap}\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}


This class implements a {\bfseries{Minimum-\/\+Heap}} which its elements are pointers to {\bfseries{lvalue {\ttfamily Entries}}} that are composed of a {\itshape key} and a {\itshape value}.  




{\ttfamily \#include $<$Min\+Heap.\+h$>$}

Inheritance diagram for Min\+Heap$<$ K, V $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_min_heap}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_min_heap_ad33a31874c9406b784c3c40a158cd501}{Min\+Heap}} (\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$array\+To\+Build\+From, int size\+Of\+Array\+To\+Build\+From)
\begin{DoxyCompactList}\small\item\em Constructor, initializes the {\itshape array}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_min_heap_ad7b6335a707b33ba813911d9396c40a6}{Min\+Heap}} (int \mbox{\hyperlink{class_min_heap_a6e37d28efb033ff005ad704809af28b4}{physical\+Size}})
\begin{DoxyCompactList}\small\item\em Constructor, sets the {\ttfamily physical\+Size} of the {\itshape array} to be {\ttfamily physical\+Size}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_min_heap_a8cfd4f3ec701187c24893f6d4a9063d8}{Min\+Heap}} ()=default
\begin{DoxyCompactList}\small\item\em Default empty constructor. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{class_min_heap_a6041d18dee6992810ede4a3444b31738}{$\sim$\+Min\+Heap}} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$ \mbox{\hyperlink{class_min_heap_a6f4be46b00c888580c5f3afe41865930}{delete\+Min}} () override
\begin{DoxyCompactList}\small\item\em Deletes the {\itshape minimal element} from the heap, and returns it. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$ \mbox{\hyperlink{class_min_heap_a2774a39578ec0f31204e97df1645cd30}{delete\+Min}} (bool fix\+Heap\+After\+Deletion)
\begin{DoxyCompactList}\small\item\em Deletes the {\itshape minimal element} from the heap, and returns it. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_min_heap_aeee64b5f9f692ab7023c26f49279ef16}{insert}} (\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$element\+To\+Insert) override
\begin{DoxyCompactList}\small\item\em Inserts the {\ttfamily element\+To\+Insert} to the heap. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap}} (int index\+To\+Fix\+From) override
\begin{DoxyCompactList}\small\item\em This method handles a heap that is {\itshape valid} from the root downwards until the {\ttfamily index\+To\+Fix\+From}, which from there and on downwards, the heap is {\itshape invalid} -\/ means\+: that the {\ttfamily node} in the {\ttfamily index\+To\+Fix\+From} is no smaller than both of its children. The method ensures to {\itshape correct} the heap by {\itshape fixing} its validity -\/ means, checking that each {\ttfamily node} is smaller than both of its children. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_min_heap_a3aeffb1e6116afdbc3981e0b2280ecb3}{build\+Heap}} (\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$array\+To\+Build\+From, int size\+Of\+Array\+To\+Build\+From) override
\begin{DoxyCompactList}\small\item\em Builds a {\bfseries{Minimum-\/\+Heap}} by giving an {\ttfamily array\+To\+Build\+From} of {\bfseries{lvalue {\ttfamily Entries}}} as a parameter. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_min_heap_a7edac6f943f3e143fbf45b529e70a8e4}{is\+Empty}} () override
\begin{DoxyCompactList}\small\item\em returns a boolean value that determines whether this heap is empty or not. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_min_heap_ae6f21519950cc55c5b470d07ee01a062}{make\+Empty}} () override
\begin{DoxyCompactList}\small\item\em clears the heap from elements. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_min_heap_a1b020a274541d1da5c5d34ab43515a19}{delete\+Min\+When\+There\+Are\+Two\+Or\+More\+Elements}} (bool fix\+Heap\+After\+Deletion)
\begin{DoxyCompactList}\small\item\em This method is a {\itshape private} method, that represents the case when there are {\ttfamily 2} or more elements in the heap. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_min_heap_a658f6c362036350b5145178e88e57051}{insert\+When\+There\+Is\+Enough\+Space}} (\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$element\+To\+Insert)
\begin{DoxyCompactList}\small\item\em This method is a {\itshape private} method, that represents the case when there is enough space in the heap to insert an additional {\ttfamily element\+To\+Insert} element. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_min_heap_abf27ed86919364739d0c6d508a8ae9a5}{fix\+Heap\+Legal\+Index}} (int index\+To\+Fix\+From)
\begin{DoxyCompactList}\small\item\em This method is a {\itshape private} method, that represents the case when the provided {\ttfamily current\+Index} is a legal index. This method is being invoked by the \mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap(int)}} method. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_min_heap_a8f24129c56d65d760c4d0e4460e8d27a}{fix\+Heap\+While}} (int current\+Index)
\begin{DoxyCompactList}\small\item\em This method is a {\itshape private} method, that represents a {\ttfamily while} that is being invoked by the \mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap(int)}} method. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$$\ast$ \mbox{\hyperlink{class_min_heap_a889e4bc48d8430fa841532b25dc000e4}{array}} = nullptr
\item 
int \mbox{\hyperlink{class_min_heap_a6e37d28efb033ff005ad704809af28b4}{physical\+Size}} = 0
\begin{DoxyCompactList}\small\item\em The {\itshape physical-\/size} of the {\itshape array}. Initialized to {\ttfamily 0}. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_min_heap_aa5f4e762e12a9ea582b476c9520f2e91}{logical\+Size}} = 0
\begin{DoxyCompactList}\small\item\em The {\itshape logical-\/size} of the {\itshape array}. Initialized to {\ttfamily 0}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
std\+::ostream \& \mbox{\hyperlink{class_min_heap_a81a7799f8217c5db84b7eec767932d2f}{operator$<$$<$}} (std\+::ostream \&os, const \mbox{\hyperlink{class_min_heap}{Min\+Heap}} \&heap)
\begin{DoxyCompactList}\small\item\em std\+::ostream {\ttfamily operator $<$$<$} print method. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename K, typename V$>$\newline
class Min\+Heap$<$ K, V $>$}

This class implements a {\bfseries{Minimum-\/\+Heap}} which its elements are pointers to {\bfseries{lvalue {\ttfamily Entries}}} that are composed of a {\itshape key} and a {\itshape value}. 

\begin{DoxyItemize}
\item Once the heap has been built by \mbox{\hyperlink{class_min_heap_a3aeffb1e6116afdbc3981e0b2280ecb3}{build\+Heap}} or \mbox{\hyperlink{class_min_heap_ad33a31874c9406b784c3c40a158cd501}{Min\+Heap(\+Entry$<$\+K, V$>$ $\ast$,int)}}, its {\itshape physical-\/size} is treated as a constant -\/ thus unchangeable. In case the user wishes to change the {\itshape physical-\/size} of the heap, there is a {\itshape must} to invoke \mbox{\hyperlink{class_min_heap_a3aeffb1e6116afdbc3981e0b2280ecb3}{build\+Heap}} again. \item The heap compares its elements to each other, by the comparable {\ttfamily key} field located in each {\ttfamily \mbox{\hyperlink{class_entry}{Entry}}} element. 
\begin{DoxyTemplParams}{Template Parameters}
{\em K} & the type of {\itshape key} in the entry. \\
\hline
{\em V} & the type of {\itshape value} in the entry. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyNote}{Note}
The terms {\ttfamily element}, {\ttfamily node} and \textquotesingle{}entry\textquotesingle{} are synonyms. 
\end{DoxyNote}
\begin{DoxyAttention}{Attention}
The {\ttfamily Entries} pointed must be {\bfseries{lvalues}}. 
\end{DoxyAttention}
\begin{DoxyAuthor}{Author}
Tal Yacob, ID\+: 208632778. 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
1.\+0 
\end{DoxyVersion}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_entry}{Entry}} 
\end{DoxySeeAlso}
\end{DoxyItemize}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_min_heap_ad33a31874c9406b784c3c40a158cd501}\label{class_min_heap_ad33a31874c9406b784c3c40a158cd501}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!MinHeap@{MinHeap}}
\index{MinHeap@{MinHeap}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{MinHeap()}{MinHeap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
\mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::\mbox{\hyperlink{class_min_heap}{Min\+Heap}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$}]{array\+To\+Build\+From,  }\item[{int}]{size\+Of\+Array\+To\+Build\+From }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructor, initializes the {\itshape array}. 

Builds a {\bfseries{Minimum-\/\+Heap}} by giving an {\ttfamily array\+To\+Build\+From} of {\bfseries{lvalue {\ttfamily Entries}}} as a parameter. Done by invoking the \mbox{\hyperlink{class_min_heap_a3aeffb1e6116afdbc3981e0b2280ecb3}{build\+Heap}} method. 
\begin{DoxyParams}{Parameters}
{\em array\+To\+Build\+From} & the given array of elements to build the heap from. \\
\hline
{\em size\+Of\+Array\+To\+Build\+From} & the size of the array to build the heap from. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_min_heap_a3aeffb1e6116afdbc3981e0b2280ecb3}{build\+Heap}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_min_heap_ad7b6335a707b33ba813911d9396c40a6}\label{class_min_heap_ad7b6335a707b33ba813911d9396c40a6}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!MinHeap@{MinHeap}}
\index{MinHeap@{MinHeap}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{MinHeap()}{MinHeap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
\mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::\mbox{\hyperlink{class_min_heap}{Min\+Heap}} (\begin{DoxyParamCaption}\item[{int}]{physical\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructor, sets the {\ttfamily physical\+Size} of the {\itshape array} to be {\ttfamily physical\+Size}. 

\begin{DoxyNote}{Note}
the content of the {\itshape array} remains empty. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em physical\+Size} & set the {\ttfamily physical\+Size} of the array to be this size. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_min_heap_a8cfd4f3ec701187c24893f6d4a9063d8}\label{class_min_heap_a8cfd4f3ec701187c24893f6d4a9063d8}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!MinHeap@{MinHeap}}
\index{MinHeap@{MinHeap}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{MinHeap()}{MinHeap()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
\mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::\mbox{\hyperlink{class_min_heap}{Min\+Heap}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



Default empty constructor. 

\mbox{\Hypertarget{class_min_heap_a6041d18dee6992810ede4a3444b31738}\label{class_min_heap_a6041d18dee6992810ede4a3444b31738}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!````~MinHeap@{$\sim$MinHeap}}
\index{````~MinHeap@{$\sim$MinHeap}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$MinHeap()}{~MinHeap()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
virtual \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::$\sim$\mbox{\hyperlink{class_min_heap}{Min\+Heap}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Destructor. 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_min_heap_a3aeffb1e6116afdbc3981e0b2280ecb3}\label{class_min_heap_a3aeffb1e6116afdbc3981e0b2280ecb3}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!buildHeap@{buildHeap}}
\index{buildHeap@{buildHeap}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{buildHeap()}{buildHeap()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::build\+Heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$}]{array\+To\+Build\+From,  }\item[{int}]{size\+Of\+Array\+To\+Build\+From }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Builds a {\bfseries{Minimum-\/\+Heap}} by giving an {\ttfamily array\+To\+Build\+From} of {\bfseries{lvalue {\ttfamily Entries}}} as a parameter. 

Done by making an array of pointers to the elements given in the {\ttfamily array\+To\+Build\+From}. 
\begin{DoxyParams}{Parameters}
{\em array\+To\+Build\+From} & the given array of elements to build the heap from. \\
\hline
{\em size\+Of\+Array\+To\+Build\+From} & the size of the array to build the heap from. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
In case there is already an {\ttfamily allocated} {\ttfamily array} in this heap, this method ensures to {\ttfamily delete \mbox{[}\mbox{]}} it {\itshape before} handling the building process. 
\end{DoxyNote}
\begin{DoxyAttention}{Attention}
the {\ttfamily Entries} elements in the {\ttfamily array\+To\+Build\+From} must be {\bfseries{lvalues}}. 
\end{DoxyAttention}


Implements \mbox{\hyperlink{class_min_heap_a_d_t_aa726874d27400106be78034fcee2e130}{Min\+Heap\+ADT$<$ K, V $>$}}.

\mbox{\Hypertarget{class_min_heap_a6f4be46b00c888580c5f3afe41865930}\label{class_min_heap_a6f4be46b00c888580c5f3afe41865930}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!deleteMin@{deleteMin}}
\index{deleteMin@{deleteMin}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{deleteMin()}{deleteMin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
\mbox{\hyperlink{class_entry}{Entry}}$<$K, V$>$$\ast$ \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::delete\+Min (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Deletes the {\itshape minimal element} from the heap, and returns it. 

\begin{DoxyNote}{Note}
After removing the {\itshape minimal element} from the heap, this method calls the {\itshape fix\+Heap(0)} method, in order to fix the heap afterwards. 
\end{DoxyNote}
\begin{DoxyAttention}{Attention}
in case the {\ttfamily logical\+Size} of the {\itshape array} is 0, this method returns {\ttfamily null\+\_\+ptr}. 
\end{DoxyAttention}
\begin{DoxyReturn}{Returns}
the {\itshape minimal element} removed from the heap. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::logic\+\_\+error} & in case the heap is already empty. \\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap(int)}} 
\end{DoxySeeAlso}


Implements \mbox{\hyperlink{class_min_heap_a_d_t_aad46f6fbc56041d20c3130dcf5b42d5e}{Min\+Heap\+ADT$<$ K, V $>$}}.

\mbox{\Hypertarget{class_min_heap_a2774a39578ec0f31204e97df1645cd30}\label{class_min_heap_a2774a39578ec0f31204e97df1645cd30}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!deleteMin@{deleteMin}}
\index{deleteMin@{deleteMin}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{deleteMin()}{deleteMin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
\mbox{\hyperlink{class_entry}{Entry}}$<$K, V$>$$\ast$ \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::delete\+Min (\begin{DoxyParamCaption}\item[{bool}]{fix\+Heap\+After\+Deletion }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deletes the {\itshape minimal element} from the heap, and returns it. 

\begin{DoxyRefDesc}{Deprecated}
\item[\mbox{\hyperlink{deprecated__deprecated000001}{Deprecated}}]Caution when setting {\ttfamily fix\+Heap\+After\+Deletion} to {\ttfamily false}.\end{DoxyRefDesc}


\begin{DoxyNote}{Note}
After removing the {\itshape minimal element} from the heap, this method calls the {\itshape fix\+Heap(0)} method, in order to fix the heap afterwards -\/ only if the {\ttfamily fix\+Heap\+After\+Deletion} parameter is {\ttfamily true}. 
\end{DoxyNote}
\begin{DoxyAttention}{Attention}
in case the {\ttfamily logical\+Size} of the {\itshape array} is 0, this method returns {\ttfamily null\+\_\+ptr}. 
\end{DoxyAttention}

\begin{DoxyParams}{Parameters}
{\em fix\+Heap\+After\+Deletion} & determines if the method will call the {\itshape fix\+Heap(0)} method, after deletion, to ensure that the heap is still valid. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the {\itshape minimal element} removed from the heap. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::logic\+\_\+error} & in case the heap is already empty. \\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap(int)}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_min_heap_a1b020a274541d1da5c5d34ab43515a19}\label{class_min_heap_a1b020a274541d1da5c5d34ab43515a19}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!deleteMinWhenThereAreTwoOrMoreElements@{deleteMinWhenThereAreTwoOrMoreElements}}
\index{deleteMinWhenThereAreTwoOrMoreElements@{deleteMinWhenThereAreTwoOrMoreElements}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{deleteMinWhenThereAreTwoOrMoreElements()}{deleteMinWhenThereAreTwoOrMoreElements()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::delete\+Min\+When\+There\+Are\+Two\+Or\+More\+Elements (\begin{DoxyParamCaption}\item[{bool}]{fix\+Heap\+After\+Deletion }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



This method is a {\itshape private} method, that represents the case when there are {\ttfamily 2} or more elements in the heap. 

\begin{DoxyNote}{Note}
After removing the {\itshape minimal element} from the heap, this method calls the {\itshape fix\+Heap(0)} method, in order to fix the heap afterwards -\/ only if the {\ttfamily fix\+Heap\+After\+Deletion} parameter is {\ttfamily true}. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em fix\+Heap\+After\+Deletion} & determines if the method will call the {\itshape fix\+Heap(0)} method, after deletion, to ensure that the heap is still valid. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_min_heap_a6f4be46b00c888580c5f3afe41865930}{delete\+Min()}} 

\mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap(int)}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_min_heap_ab5f16032e4084a73454be12e70ee3878}\label{class_min_heap_ab5f16032e4084a73454be12e70ee3878}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!fixHeap@{fixHeap}}
\index{fixHeap@{fixHeap}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{fixHeap()}{fixHeap()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::fix\+Heap (\begin{DoxyParamCaption}\item[{int}]{index\+To\+Fix\+From }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



This method handles a heap that is {\itshape valid} from the root downwards until the {\ttfamily index\+To\+Fix\+From}, which from there and on downwards, the heap is {\itshape invalid} -\/ means\+: that the {\ttfamily node} in the {\ttfamily index\+To\+Fix\+From} is no smaller than both of its children. The method ensures to {\itshape correct} the heap by {\itshape fixing} its validity -\/ means, checking that each {\ttfamily node} is smaller than both of its children. 


\begin{DoxyParams}{Parameters}
{\em index\+To\+Fix\+From} & the method fixes the heap from this index downwards until the leaves of the heap. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
this method will continue to run until the root is no longer smaller than both of its children, or when the root is a leaf. 
\end{DoxyNote}
\begin{DoxyAttention}{Attention}
there is no use to give {\ttfamily index\+To\+Fix\+From} that is larger than {\ttfamily (logical\+Size / 2)}, because indexes larger than {\ttfamily (logical\+Size / 2)} point to leaf {\ttfamily node}s, thus the method will have no effect, as explained earlier. 
\end{DoxyAttention}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & in case the index provided is out of range. \\
\hline
\end{DoxyExceptions}


Implements \mbox{\hyperlink{class_min_heap_a_d_t_a448c7198ad5aa4f525d017cce6cb5237}{Min\+Heap\+ADT$<$ K, V $>$}}.

\mbox{\Hypertarget{class_min_heap_abf27ed86919364739d0c6d508a8ae9a5}\label{class_min_heap_abf27ed86919364739d0c6d508a8ae9a5}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!fixHeapLegalIndex@{fixHeapLegalIndex}}
\index{fixHeapLegalIndex@{fixHeapLegalIndex}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{fixHeapLegalIndex()}{fixHeapLegalIndex()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::fix\+Heap\+Legal\+Index (\begin{DoxyParamCaption}\item[{int}]{index\+To\+Fix\+From }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



This method is a {\itshape private} method, that represents the case when the provided {\ttfamily current\+Index} is a legal index. This method is being invoked by the \mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap(int)}} method. 


\begin{DoxyParams}{Parameters}
{\em current\+Index} & has been checked as a legal index. should be in between {\ttfamily 0} and {\ttfamily (logical\+Size / 2)}. Represents the index to {\itshape fix\+Heap} from. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap(int)}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_min_heap_a8f24129c56d65d760c4d0e4460e8d27a}\label{class_min_heap_a8f24129c56d65d760c4d0e4460e8d27a}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!fixHeapWhile@{fixHeapWhile}}
\index{fixHeapWhile@{fixHeapWhile}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{fixHeapWhile()}{fixHeapWhile()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::fix\+Heap\+While (\begin{DoxyParamCaption}\item[{int}]{current\+Index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



This method is a {\itshape private} method, that represents a {\ttfamily while} that is being invoked by the \mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap(int)}} method. 

The {\ttfamily while} loop has {\ttfamily 2} stop conditions\+: \begin{DoxyItemize}
\item there are no children to the {\ttfamily node} that is being iterated ( = the {\ttfamily node} that is being iterated is a {\ttfamily leaf}. \item the {\ttfamily node} that is being iterated is {\itshape not} smaller than each of its children. 
\begin{DoxyParams}{Parameters}
{\em current\+Index} & should be in between {\ttfamily 0} and {\ttfamily (logical\+Size / 2)}. Represents the index to {\itshape fix\+Heap} from. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_min_heap_ab5f16032e4084a73454be12e70ee3878}{fix\+Heap(int)}} 
\end{DoxySeeAlso}
\end{DoxyItemize}
\mbox{\Hypertarget{class_min_heap_aeee64b5f9f692ab7023c26f49279ef16}\label{class_min_heap_aeee64b5f9f692ab7023c26f49279ef16}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!insert@{insert}}
\index{insert@{insert}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$}]{element\+To\+Insert }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Inserts the {\ttfamily element\+To\+Insert} to the heap. 


\begin{DoxyParams}{Parameters}
{\em element\+To\+Insert} & the element to insert to the heap. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::logic\+\_\+error} & in case the heap is already full. \\
\hline
\end{DoxyExceptions}


Implements \mbox{\hyperlink{class_min_heap_a_d_t_a414eb805e88dfa1995c481571ff90d1b}{Min\+Heap\+ADT$<$ K, V $>$}}.

\mbox{\Hypertarget{class_min_heap_a658f6c362036350b5145178e88e57051}\label{class_min_heap_a658f6c362036350b5145178e88e57051}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!insertWhenThereIsEnoughSpace@{insertWhenThereIsEnoughSpace}}
\index{insertWhenThereIsEnoughSpace@{insertWhenThereIsEnoughSpace}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{insertWhenThereIsEnoughSpace()}{insertWhenThereIsEnoughSpace()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::insert\+When\+There\+Is\+Enough\+Space (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_entry}{Entry}}$<$ K, V $>$ $\ast$}]{element\+To\+Insert }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



This method is a {\itshape private} method, that represents the case when there is enough space in the heap to insert an additional {\ttfamily element\+To\+Insert} element. 


\begin{DoxyParams}{Parameters}
{\em element\+To\+Insert} & is the element required to be inserted to the heap. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_min_heap_aeee64b5f9f692ab7023c26f49279ef16}{insert(\+Entry$<$\+K, V$>$ $\ast$)}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_min_heap_a7edac6f943f3e143fbf45b529e70a8e4}\label{class_min_heap_a7edac6f943f3e143fbf45b529e70a8e4}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{isEmpty()}{isEmpty()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
bool \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::is\+Empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



returns a boolean value that determines whether this heap is empty or not. 

\begin{DoxyReturn}{Returns}
boolean value of {\itshape true} if the heap is empty, or else, {\itshape false} if the heap is not empty. 
\end{DoxyReturn}


Implements \mbox{\hyperlink{class_min_heap_a_d_t_a5a10590c084fd8d559e55ff9b7ba57c5}{Min\+Heap\+ADT$<$ K, V $>$}}.

\mbox{\Hypertarget{class_min_heap_ae6f21519950cc55c5b470d07ee01a062}\label{class_min_heap_ae6f21519950cc55c5b470d07ee01a062}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!makeEmpty@{makeEmpty}}
\index{makeEmpty@{makeEmpty}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{makeEmpty()}{makeEmpty()}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::make\+Empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



clears the heap from elements. 



Implements \mbox{\hyperlink{class_min_heap_a_d_t_a772c058414cf8c8abb5ab6796d3d09d9}{Min\+Heap\+ADT$<$ K, V $>$}}.



\doxysubsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{class_min_heap_a81a7799f8217c5db84b7eec767932d2f}\label{class_min_heap_a81a7799f8217c5db84b7eec767932d2f}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$}{operator<<}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
std\+::ostream\& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$ \&}]{heap }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



std\+::ostream {\ttfamily operator $<$$<$} print method. 



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_min_heap_a889e4bc48d8430fa841532b25dc000e4}\label{class_min_heap_a889e4bc48d8430fa841532b25dc000e4}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!array@{array}}
\index{array@{array}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{array}{array}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
\mbox{\hyperlink{class_entry}{Entry}}$<$K, V$>$$\ast$$\ast$ \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::array = nullptr\hspace{0.3cm}{\ttfamily [private]}}

Array of pointers to {\bfseries{lvalue {\ttfamily Entries}}} that serve as {\ttfamily elements}. Initialized to {\ttfamily nullptr}. \mbox{\Hypertarget{class_min_heap_aa5f4e762e12a9ea582b476c9520f2e91}\label{class_min_heap_aa5f4e762e12a9ea582b476c9520f2e91}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!logicalSize@{logicalSize}}
\index{logicalSize@{logicalSize}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{logicalSize}{logicalSize}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
int \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::logical\+Size = 0\hspace{0.3cm}{\ttfamily [private]}}



The {\itshape logical-\/size} of the {\itshape array}. Initialized to {\ttfamily 0}. 

\mbox{\Hypertarget{class_min_heap_a6e37d28efb033ff005ad704809af28b4}\label{class_min_heap_a6e37d28efb033ff005ad704809af28b4}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!physicalSize@{physicalSize}}
\index{physicalSize@{physicalSize}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{physicalSize}{physicalSize}}
{\footnotesize\ttfamily template$<$typename K , typename V $>$ \\
int \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::physical\+Size = 0\hspace{0.3cm}{\ttfamily [private]}}



The {\itshape physical-\/size} of the {\itshape array}. Initialized to {\ttfamily 0}. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{_min_heap_8h}{Min\+Heap.\+h}}\end{DoxyCompactItemize}
